//Redux_card_+_Sort_popup\\

//№1 Sort.jsx
#Сортировка popup открыта при нажатие на любую другую область сайта окно должно закрываться

1. Создать useRef и повесить его на гланвый div sort.

2. создать useEffect в нём создать константу с именнем clickOutside: у неё есть (event) => условие if ,
"(у event есть .composedPath() - путь нахождения html разметки, потом методом includes(находить ref.current))"
"!если клика не было по сплывающему окну ,менять состояние popup на false"

2.1 Ниже константы clickOutside, Создать событие клика через document.body.addEventListener по клику и 
добавить в этот метод функцию сворачивания окна.

3. В useEffect при изменение компонента перерендеривается addEventListener, нужно делать unMount в компоненте.
"return () => {} эта логика в useEffect отвечает за размонтирование. Внутри у body удалить по клику clickOutside.
Логика таже как и добавление на клик."

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//№2 src/redux/slices/cartSlice
#Добавить такие reducers: addItems,minusItem,removeItem,clearItems.

addItems: {
1. Переменная findItem ,обратиться к состоянию items вызвать метод find 
"и сравнивать состояние объекта с active.payload.id. Условие if findItem есть: findItem.count добавлять ++.
Иначе: state.items.push объект{} spread.operator изменяемого состояния это - action.payload и count: 1"

2. Обратиться к состоянию state.totalPrice = state.items вызвать метод reduce (callback + initialValue),
return "initialValue.price * initialValue.count + callback. это - цена умноженная на количество, и применяет
эту функцию к элементам массива последовательно, сводя их к одному значению. Начальное состояние reduce 0."
}

minusItem: {
1. Переменная findItem ,обратиться к состоянию items вызвать метод find 
"и сравнивать состояние объекта с active.payload.id . Условие if findItem есть: findItem.count убовлять --"

2. Обратиться к состоянию state.totalPrice = state.items вызвать метод reduce (callback + initialValue),
return "initialValue.price * initialValue.count - callback. это - цена умноженная на количество, и применяет
эту функцию к элементам массива последовательно, сводя их к одному значению. Начальное состояние reduce 0."
}

removeItem: {
1. Обратиться к Cостоянию state.items = state.items. вызвать метод: filter obj у него обратиться к id != 
"id которого не совподает с action.payload."
}

clearItems: {
"
Обращаться к items[] = Очищать на пустой массивом.
Обращаться к items[] = Очищать totalPrice на 0.
"
}

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//№3 Header.jsx
1. Вытащить состояния из Redux/cart {items, totalPrice} ,заменить:
"totalPrice: для цены price, items: сложыть общее количесто count."

2. Переменная totalCount: для подсчёта всех count из объекта items и суммируем их, reduce:
"делаем подсчёт sum + item.count, начальное состояние 0"

#Вешаем обработчики событий на теги. totalPrice & totalCount

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//№4 PizzaBlock.jsx
1. Создать функцию onClickAddItems: которая будет отправлять данные в корзину,
"внутри создать константу, напримет: items передать как объект такие параметры 
id,
title,
price,
imageUrl,
size: sizes[activeSize],
type: TYPES_PROPERTY[activeType]"

2. Внутри функции onClickAddItems: Вызвать dispatch передать внего созданное состояние корзины для всех элементов.
"передать данные которые хранятся в константе"

3. Создать состояние счётчика cartItem: вызвать useSelector(
"obj , у obj.cart.items вызвать метод find и уже в нём сравнивать obj.id который в redux с id который 
мы получили из данных пицци в пропсах" 
) 

4. Написать проверку счётчика, есть ли выбронная пицца. addedCount: 
"тернарником если cartItem есть выводить его count иначе 0."

5. Отображать Тег <i> - это число выбронной конкретной пицци. 
"Условие addedCount > 0 && если да. <i>Отображать addedCount</i>"

#Вешаем обработчики событий на теги.

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//№5 Cart.jsx
1. Вытащить состояния из Redux/cart {items, totalPrice} ,заменить:
"totalPrice: для цены price, items: сложыть общее количесто count."

2. Переменная totalCount: для подсчёта всех count из объекта items и суммируем их, reduce:
"делаем подсчёт sum + item.count, начальное состояние 0"

3. Создать функцию onClickClear ,условие user нажал на Очистить корзину  if: window.confirm('text with question')
"в dispatch передать вызов clearItems()"

4. Условный рендер до основного return
"return if !totalPrice return <CartEmpty />"

5. <CartItems/> пробижатся методом map передать пропсы все через spread.operator и key id

#Вешаем обработчики событий на теги. totalPrice & totalCount

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\

//№6 CartItems.jsx
1. Получить пропсы [id,title,type,size,price,count,imageUrl] заменить все данные на пропсы,
"цену выводить: цену * количество".

2. Создать функцию onClickPlus и dispatch изменения в addItem передовать объект id.
"Потому что в корзине: пиццы уже будут создны.Нам осталось добавлять определённую пиццу по её идентификатору"

3. Создать функцию onClickMinus и dispatch изменения в minusItem(id)

4. Создать функцию onClickRemove ,условие user нажал на удалить 1 товар if: window.confirm('text')
"dispatch изменения в removeItem(id)"

#Вешаем обработчики событий на теги.

/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
#############################################Helper#############################################

//Используем: [
  useRef,
  includes,
  push,
  filter,
  reduce,
  find,
  ? : ,
]

#includes - это метод который используется для проверки наличия определенного элемента в массиве или строки.
#Этот метод возвращает true, если элемент найден, и false, если нет.

#push - это метод массива который используется для добавления одного или нескольких элементов в конец массива. 
#Этот метод изменяет исходный массив, добавляя новые элементы в его конец.

#filter - это метод массива который используется для фильтрации элементов массива на основе заданной функции. 
#Этот метод создает новый массив, содержащий только те элементы из исходного массива, для которых функция
#фильтрации возвращает true.Элементы, для которых функция фильтрации возвращает false, не включаются в новый массив.

"Метод reduce() - это метод массивов который используется для выполнения операции над всеми элементами массива с целью
#получения одного значения в результате.Этот метод принимает функцию обратного вызова (callback) и начальное значение
#(необязательно), и применяет эту функцию к элементам массива последовательно, сводя их к одному значению.
#Пример: array.reduce(callback[, initialValue]) " 

#Метод find() - это метод массивов который используется для поиска первого элемента в массиве, удовлетворяющего
#заданному условию (предикату). Как только элемент, удовлетворяющий условию, найден, метод find() 
#возвращает этот элемент, и дальнейший поиск прекращается.